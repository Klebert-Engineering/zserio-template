
/**
 * Automatically generated by Zserio C++ extension version 1.2.0.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>


namespace host
{

namespace
{

template <class T, class V>
class _elementFactory_MapList_maps
{
public:
    explicit _elementFactory_MapList_maps(MapList<T,V>& owner) : m_owner(owner) {}

    void create(void* storage, zserio::BitStreamReader& _in, size_t _index)
    {
        (void)_index;
        new (storage) host::Map<T,V>(_in);
    }

private:
    MapList<T,V>& m_owner;
};

template <class T, class V>
class _elementChildrenInitializer_MapList_maps
{
public:
    _elementChildrenInitializer_MapList_maps() {}

    void initialize(host::Map<T,V>& element, size_t)
    {
        element.initializeChildren();
    }
};

} // namespace

template <class T,class V>
MapList<T,V>::MapList()
{
}

template <class T,class V>
MapList<T,V>::MapList(zserio::BitStreamReader& _in)
{
    read(_in);
}

template <class T,class V>
void MapList<T,V>::initializeChildren()
{
    m_maps.initializeElements(_elementChildrenInitializer_MapList_maps<T,V>());
}

template <class T,class V>
zserio::ObjectArray<host::Map<T, V>>& MapList<T,V>::getMaps()
{
    return m_maps;
}

template <class T,class V>
const zserio::ObjectArray<host::Map<T, V>>& MapList<T,V>::getMaps() const
{
    return m_maps;
}

template <class T,class V>
void MapList<T,V>::setMaps(const zserio::ObjectArray<host::Map<T, V>>& maps)
{
    m_maps = maps;
}

template <class T,class V>
size_t MapList<T,V>::bitSizeOf(size_t _bitPosition) const
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition += m_maps.bitSizeOf(_endBitPosition, zserio::AutoLength());

    return _endBitPosition - _bitPosition;
}

template <class T,class V>
size_t MapList<T,V>::initializeOffsets(size_t _bitPosition)
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition = m_maps.initializeOffsets(_endBitPosition, zserio::AutoLength());

    return _endBitPosition;
}

template <class T,class V>
bool MapList<T,V>::operator==(const MapList& _other) const
{
    if (this != &_other)
    {
        return
                (m_maps == _other.m_maps);
    }

    return true;
}

template <class T,class V>
int MapList<T,V>::hashCode() const
{
    int _result = zserio::HASH_SEED;

        _result = zserio::calcHashCode(_result, m_maps);

    return _result;
}

template <class T,class V>
void MapList<T,V>::read(zserio::BitStreamReader& _in)
{
    m_maps.read(_in, zserio::AutoLength(), _elementFactory_MapList_maps<T,V>(*this));
}

template <class T,class V>
void MapList<T,V>::write(zserio::BitStreamWriter& _out, zserio::PreWriteAction _preWriteAction)
{
    if ((_preWriteAction & zserio::PRE_WRITE_INITIALIZE_CHILDREN) != 0)
        initializeChildren();

    m_maps.write(_out, zserio::AutoLength());
}

} // namespace host
