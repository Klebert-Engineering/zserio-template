/**
 * Automatically generated by Zserio C++ extension version 1.1.0.
 */

#ifndef HOST_MAP_H
#define HOST_MAP_H

#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/PreWriteAction.h>
#include <zserio/OptionalHolder.h>
#include <zserio/Types.h>

#include "host/Header.h"
#include "host/Value.h"

namespace host
{

template <class T, class V> class Map
{
public:
	Map():m_areChildrenInitialized(false) { };
	Map(zserio::BitStreamReader& _in):m_areChildrenInitialized(true) { read(_in); };

	Map(const Map& _other) :
		m_header(_other.m_header),
		m_type(_other.m_type),
		m_val(_other.m_val)
	{
		if (_other.m_areChildrenInitialized)
			initializeChildren();
		else
			m_areChildrenInitialized = false;
	};

	void initializeChildren()
	{
		m_val.initialize(getType());

		m_areChildrenInitialized = true;
	};

	host::Header& getHeader() { return m_header; };

	void setHeader(const host::Header& header) { m_header = header; };

	T& getType() { return m_type;  };
	void setType(T& type) { m_type = type; };

	V& getVal() { return m_val; };
	void setVal(V& val) { m_val = val; };

    size_t bitSizeOf(size_t _bitPosition = 0)
	{
		size_t _endBitPosition = _bitPosition;

		_endBitPosition += m_header.bitSizeOf(_endBitPosition);
		_endBitPosition += m_type.bitSizeOf(_endBitPosition);
		_endBitPosition += m_val.bitSizeOf(_endBitPosition);

		return _endBitPosition - _bitPosition;
	};
    size_t initializeOffsets(size_t _bitPosition)
	{
		size_t _endBitPosition = _bitPosition;

		_endBitPosition = m_header.initializeOffsets(_endBitPosition);
		_endBitPosition += m_type.initializeOffsets(_endBitPosition);
		_endBitPosition = m_val.initializeOffsets(_endBitPosition);

		return _endBitPosition;
	};


    int hashCode() const
	{
		int _result = zserio::HASH_SEED;

		_result = zserio::calcHashCode(_result, m_header);
		_result = zserio::calcHashCode(_result, m_type);
		_result = zserio::calcHashCode(_result, m_val);

		return _result;
	};

    void read(zserio::BitStreamReader& _in)
	{
		m_header.read(_in);
		m_type.read(_in);
		m_val.initialize(m_type);
		m_val.read(_in);
	};

    void write(zserio::BitStreamWriter& _out,
            zserio::PreWriteAction _preWriteAction = zserio::ALL_PRE_WRITE_ACTIONS)
	{
		if ((_preWriteAction & zserio::PRE_WRITE_INITIALIZE_CHILDREN) != 0)
			initializeChildren();

		m_header.write(_out, zserio::NO_PRE_WRITE_ACTION);
		m_type.write(_out, zserio::NO_PRE_WRITE_ACTION);
		m_val.write(_out, zserio::NO_PRE_WRITE_ACTION);
	};

private:
    bool m_areChildrenInitialized;

    host::Header m_header;
    T m_type;
    V m_val;
};

} // namespace host

#endif // HOST_MAP_H
